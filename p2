#!/usr/bin/env bash

VERSION="v1.0.0"

# Constant variables
P2=`basename "$0"`
MOUNTPOINT="$HOME/.local/share/pwnpad/mounts"

# Print general usage and exits
USAGE() {
    printf "USAGE:
  ${P2} <SUBCOMMAND>

SUBCOMMAND:
  build     Build Docker image
  attach    Attach into container
  rm        Remove container and its volumes
  kill      Stop container from running
  volume    Enter into container's volume
  ls        List pwnpad instances
  update    Update image to the latest build

HELP:
  ${P2} build -h
  ${P2} attach -h
  ${P2} rm -h\n"
  exit 1
}

# Build docker image
BUILD() {
    BUSE() {
        printf "USAGE:
  ${P2} build [OPTIONS]
OPTIONS:
  -p    platform
          linux/amd64, linux/arm64
  -i    select image (default: latest)
          latest, extra, bare\n"
        exit 1
    }

    root="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

    platform=""
    tag="latest"
    dockerfile="Dockerfile"

    shift
    while getopts ":i:p:" options
    do
        case $options in
            p) platform="--platform $OPTARG"
                ;;
            i) tag="$OPTARG"
                ;;
            *) BUSE
                ;;
        esac
    done

    if [ ${tag} == "extra" ]; then
        dockerfile="Dockerfile-extra"
    fi

    if [ ${tag} == "bare" ]; then
        dockerfile="Dockerfile-bare"
    fi

    if [ ! -d "${root}/docker" ]; then
        printf "You may not have the full Git repository installed\n"
        exit 1
    fi

    docker image build $platform -f $root/docker/${dockerfile} -t platypew/pwnpad:${tag} $root
}

# Start and attach docker container
ATTACH() {
    AUSE() {
        printf "USAGE:
  ${P2} attach [OPTIONS] <BOX>
OPTIONS:
  -P    use privileged mode (not recommended)
  -S    use sys_admin capability (required for chroot)
  -X    support X11 forwarding
  -D    run as daemon mode
  -e    use environmental variables
          FOO=bar
  -d    display (use with -X)
  -p    port range (default: 22, default port will map to random host port between 40000 and 40999)
          1337:1337
          1337-31337:1337-31337
  -v    mount volumes
          /foo/bar:/foo/bar
  -i    select image (default: latest)
          latest, extra\n"
        exit 1
    }

    env=""
    volume=""
    admin=""
    priv=""
    xsupport=""
    display=""
    image="latest"

    detach=0

    shift
    while getopts ":PSXDe:d:p:v:i:" options
    do
        case $options in
            P) priv="--privileged"
                ;;
            S)
                if [[ $(uname -m) != "x86_64" ]]; then
                    admin="--cap-add=SYS_ADMIN"
                fi
                ;;
            X) xsupport="-v /tmp/.X11-unix:/tmp/.X11-unix:rw"
                ;;
            D) detach=1
                ;;
            d) display="$OPTARG"
                ;;
            e) env="${env} -e $OPTARG"
                ;;
            p) port="${port} -p $OPTARG"
                ;;
            v) volume="${volume} -v $OPTARG"
                ;;
            i) image="$OPTARG"
                ;;
            *) AUSE
                ;;
        esac
    done
    shift $(($OPTIND - 1))

    box_name=${1}

    if [ -z ${box_name} ]; then
        AUSE
    fi


    # Check if there's display running x11
    if [[ ! -z $xsupport ]]; then
        if [[ ! -d "/tmp/.X11-unix" ]]; then
            printf "/tmp/.X11-unix not found\n"
            exit 1
        fi

        if [[ -z $display ]]; then
            if [[ $OSTYPE == 'darwin'* ]]; then
                display="host.docker.internal:0"
            else
                display=$DISPLAY
            fi
        fi

        xsupport="${xsupport} -e DISPLAY=${display}"
    fi

    tz=""
    if [[ $OSTYPE == 'darwin'* ]]; then
        tz=$(readlink /etc/localtime | sed 's#/var/db/timezone/zoneinfo/##g')
    else
        tz=$(readlink /etc/localtime | sed 's#/usr/share/zoneinfo/##g')
    fi

    printf "Making directory...\n"
    mkdir $MOUNTPOINT/${box_name} 2> /dev/null
    printf "Directory located at: $MOUNTPOINT/${box_name}\n"

    # Attaches if container exists
    if [ $(docker container ls -a --filter "name=^/${box_name}$" --format '{{.Names}}') ]; then
        printf "Container exists, reattaching...\n"
        docker container start ${box_name} > /dev/null
    else
        docker container run -it -d \
            -h ${box_name} \
            --name ${box_name} \
            -e TZ=${tz} \
            --cap-add=SYS_PTRACE \
            --cap-add=NET_ADMIN \
            $admin \
            --security-opt seccomp=unconfined \
            --mount type=bind,source="$MOUNTPOINT/${box_name}",target=/mnt/shared \
            --sysctl net.ipv6.conf.all.disable_ipv6=0 \
            --device /dev/net/tun \
            --cgroupns=host \
            -v /sys/fs/cgroup:/sys/fs/cgroup:rw \
            --tmpfs /run \
            --tmpfs /tmp:exec \
            ${xsupport} \
            ${priv} \
            $env $port $volume \
            platypew/pwnpad:${image} sh > /dev/null

        if [ $? -ne 0 ]; then
            printf "An error has occured. Check arguments\n\n"
            AUSE
        fi
    fi

    if [ $detach -eq 0 ]; then
        docker container exec -it "${box_name}" su pwnpad
    fi
}

# Removes pwnpad
RM() {
    RUSE() {
        printf "USAGE:
  ${P2} rm [OPTIONS] <BOX>
OPTIONS:
  -f    forcefully remove mounted shared directory\n"
        exit 1
    }

    force=0

    shift
    while getopts ":f" options
    do
        case $options in
            f) force=1
                ;;
            *) RUSE
                ;;
        esac
    done
    shift $(($OPTIND - 1))

    box_name=${1}

    printf "Are you sure you want to remove ${box_name}? This cannot be undone! (y/n) "
    read confirmation

    if [ -z $confirmation ] || [ $confirmation != "y" ]; then
        exit 0
    fi

    if [ -z ${box_name} ]; then
        RUSE
    fi

    printf "Attempting to remove container\n"
    docker container rm ${box_name} -f &> /dev/null

    if [ $? -ne 0 ]; then
        printf "Container does not exist\n\n"
        RUSE
    fi

    printf "Cleaning directory\n"
    if [ $force -eq 0 ]; then
        rmdir $MOUNTPOINT/${box_name} 2> /dev/null

        if [ $? -ne 0 ]; then
            printf "Directory not empty, not removing...\n"
        fi
    else
        if type trash &> /dev/null; then
            trash -F $MOUNTPOINT/${box_name}
        else
            rm -rvf $MOUNTPOINT/${box_name}
        fi
    fi

}

KILL() {
    KUSE() {
        printf "USAGE:
  ${P2} kill <BOX>\n"
    }
    if [ -z $2 ] ; then
        KUSE
        exit 1
    fi

    box_name=${2}

    printf "Are you sure you want to kill ${box_name}? This will stop all processes running! (y/n) "
    read confirmation

    if [ -z $confirmation ] || [ $confirmation != "y" ]; then
        exit 0
    fi

    docker container stop "${box_name}"
}

VOLUME() {
    VUSE() {
        printf "USAGE:
  ${P2} volume <BOX>\n"
        exit 1
    }
    if [ -z $2 ]; then
        VUSE
    fi

    cd "$MOUNTPOINT/$2" 2> /dev/null
    exec $SHELL

    if [ $? -ne 0 ]; then
        VUSE
    fi
}

LIST() {
    docker container ls -a --filter "ancestor=platypew/pwnpad:latest" --filter "ancestor=platypew/pwnpad:extra" --format "table {{.Names}}\t{{.Status}}\t{{.Size}}\t{{.RunningFor}}\t{{.Ports}}"
}

UPDATE() {
    DIR=$(dirname $0)
    git -C $DIR fetch origin master && git -C $DIR pull origin master --rebase

    boxexists=$(docker container ls -a --filter "ancestor=platypew/pwnpad:latest" --filter "ancestor=platypew/pwnpad:extra" --format "table {{.Names}}\t{{.Status}}" | tail -n +2)
    if [[ ! -z $boxexists ]]; then
        printf "You have existing instances running:\n"
        echo "$boxexists"

        printf "\nUpdating will leave dangling images which may take up space and instances will no longer be tracked\n"
        printf "Updating will NOT delete any instances you have\n"
        printf "Are you sure you want to update? This cannot be undone! (y/n) "
        read confirmation

        if [ -z $confirmation ] || [ $confirmation != "y" ]; then
            exit 0
        fi
    fi


    beforeid=$(docker image ls platypew/pwnpad:latest | tail -n 1 | awk '{print $3}')
    docker image pull platypew/pwnpad:latest
    afterid=$(docker image ls platypew/pwnpad | grep none | awk '{print $3}')
    if [[ $beforeid == $afterid ]]; then
        docker image rm -f $beforeid
    fi

    beforeid=$(docker image ls platypew/pwnpad:extra | tail -n 1 | awk '{print $3}')
    docker image pull platypew/pwnpad:extra
    afterid=$(docker image ls platypew/pwnpad | grep none | awk '{print $3}')
    if [[ $beforeid == $afterid ]]; then
        docker image rm -f $beforeid
    fi
}

if ! docker version >/dev/null 2>&1; then
    printf "NOTICE:
  Cannot connect to the Docker daemon. Is the docker daemon running?\n\n"
    USAGE
fi

if [ -z ${1} ]; then
    USAGE
fi

if [ ! -d ${MOUNTPOINT} ]; then
    mkdir -p ${MOUNTPOINT}
fi

case ${1} in
    build) BUILD $@
        ;;
    attach) ATTACH $@
        ;;
    kill) KILL $@
        ;;
    rm) RM $@
        ;;
    volume) VOLUME $@
        ;;
    ls) LIST
        ;;
    update) UPDATE
        ;;
    version) printf "${VERSION}\n"
        ;;
    *) USAGE
        ;;
esac
